
/*
Оператор exists
    оператор exists является в своем роде уникальным, потому что проверяет строки,
    а не сравнивает значения столбцов и предназначен для определения наличия строк,
    возвращаемых подзапросом. Если подзапрос содержит хотя бы одну строку, то оператор
    exists возвращает истину и текущая запись помещается в результирующую таблицу,
    иначе оператор возвращает ложь и, соответсвенно, данные не записываются.
*/

 select firstName, lastName, birthDate, Email
from Students
where exists (
    select *
    from Achievements
    where Achievements.StudentId = students.Id
);

/*
    Оператор exists можно использовать совместно с оператором not для определения
    данных, которые не удовлетворяют условию.
*/

select firstName, lastName, birthDate, email
from students
where not exists (
    select *
    from Achievements
    where Achievements.StudentId = students.Id
);

/*
    Оператор any/some
        операторы any и some являются синонимами и выполняют, как это ни странно,
        одно и то же действие - осуществляет проверку выполнения заданного условия
        сравнения хотя бы одного значения из тех, которые возвращает подзапрос.
*/

select firstName, lastName, birthDate, email
from students
where Id = any (
    select StudentId
    from Achievements
    where Assesment = 20
);

/*
	Внимательный студент может возразить, что для получения такого результата будет достаточно сравнить
	результаты выполнения подзапроса при помощи оператора IN и будет абсолютно прав.
*/
SELECT FirstName, LastName, BirthDate, Email
FROM Students
WHERE Id IN (
	SELECT StudentId
	FROM Achievements
	WHERE Assesment = 10
);

/*
	Однако преимущество операторов ANY/SOME заключается в том, что их можно использовать не только
	с оператором сравнения на равенство (=), как оператор IN, но и с операторами сравнения на
	неравенство (>, <, >=, <=, <>).
*/
SELECT COUNT(*) AS [Count]
FROM Students
WHERE BirthDate < ANY (
	SELECT BirthDate
	FROM Teachers
);

/*
Оператор ALL
	Оператор ALL используется при сравнении результатов подзапроса, таким образом, чтобы указанному
	условию удовлетворяли все результаты подзапроса без исключения.
*/
SELECT FirstName, LastName, Assesment
FROM Students AS S, Achievements AS A
WHERE StudentId = S.Id AND Assesment >= ALL (
	SELECT AVG(Assesment)
	FROM Achievements
	GROUP BY StudentId
);

/*
	Операторы ANY/SOME и ALL могут применяться не только совместно с оператором WHERE, что было
	показано во всех предыдущих примерах, но и с оператором HAVING.
*/
SELECT FirstName, LastName, Assesment
FROM Students AS S,(
	SELECT StudentId, Assesment
	FROM Achievements
	GROUP BY StudentId, Assesment
	HAVING Assesment <> ALL (
		SELECT Assesment
		FROM Groups AS G, Students AS S, Achievements AS A
		WHERE S.GroupId = G.Id AND A.StudentId = S.Id AND GroupName = '3211'
		)
	) AS SA
WHERE SA.StudentId = S.Id;

/*
	Объединение результатов запросов применяется в том случае если необходимо получить совокупность строк
	двух и более запросов, которые выполняются независимо друг от друга.

	Для того чтобы результаты запросов можно было объединить они должны соответствовать определенным
	условиям совместимости:

	■ Количество столбцов в каждом запросе должно быть одинаковым;
	■ Типы данных соответствующих столбцов во всех запросах должны быть совместимы.

	Также при объединении запросов существует ряд особенностей:
	■ В результирующем наборе будут использоваться имена столбцов, которые были указаны в первом запросе;
	■ Осуществить сортировку можно только всего составного запроса, указав по его окончанию оператор ORDER BY.

UNION
	Объединение результатов запросов обеспечивается благодаря использованию ключевых слов UNION и UNION ALL.
	Ключевое слово UNION позволяет объединить результаты запросов и применяется в том случае, когда в результирующем
	наборе необходимо исключить повторяющиеся строки.
*/
SELECT FirstName + ' ' + LastName AS FullName, BirthDate
FROM Students
WHERE MONTH(BirthDate) > 5 AND MONTH(BirthDate) < 9
UNION
SELECT FirstName + ' ' + LastName, BirthDate
FROM Teachers
WHERE MONTH(BirthDate) > 5 AND MONTH(BirthDate) < 9
ORDER BY BirthDate;

/*
UNION ALL
	Ключевое слово UNION ALL также позволяет объединять результаты различных запросов, однако выполняется быстрее,
	чем UNION, потому что не тратит время на удаление дублирующих строк в объединяемых запросах.
*/
SELECT 'Spring' AS Seasons, COUNT(*) AS [Number of students]
FROM Students
WHERE MONTH(BirthDate) BETWEEN 3 AND 5
UNION ALL
SELECT 'Summer', COUNT(*)
FROM Students
WHERE MONTH(BirthDate) BETWEEN 6 AND 8
UNION ALL
SELECT 'Autumn', COUNT(*)
FROM Students
WHERE MONTH(BirthDate) BETWEEN 9 AND 11
UNION ALL
SELECT 'Winter', COUNT(*)
FROM Students
WHERE MONTH(BirthDate) IN (1, 2, 12);

/*
	Еще один пример продемонстрирует возможность использования объединения при составлении статистических отчетов.
	Например, нам необходимо получить отдельно количество студентов и преподавателей, которые родились во втором
	квартале, а также их общее количество:
*/
SELECT 'Students' AS [Second quarter], COUNT(*) AS [Count]
FROM Students
WHERE MONTH(BirthDate) BETWEEN 5 AND 8
UNION ALL
SELECT 'Teachers', COUNT(*)
FROM Teachers
WHERE MONTH(BirthDate) BETWEEN 5 AND 8
UNION ALL
SELECT 'All', SUM(AllSum.AllCount)
FROM (
	SELECT COUNT(*) AS AllCount
	FROM Students
	WHERE MONTH(BirthDate) BETWEEN 5 AND 8
	UNION ALL
	SELECT COUNT(*)
	FROM Teachers
	WHERE MONTH(BirthDate) BETWEEN 5 AND 8
) AS AllSum

/*
JOIN
	В прошлом разделе мы изучили возможность объединения результатов запросов при помощи ключевого
	слова UNION, такой вид объединения можно назвать объединением по вертикали. В свою очередь оператор
	JOIN позволяет объединять таблицы в пределах одного SQL-запроса и может считаться объединением по горизонтали.

INNER JOIN
	Внутреннее объединение двух таблиц возможно при помощи оператора INNER JOIN с указанием условия их
	объединения (предиката) после ключевого слова ON. При выполнении оператора INNER JOIN каждая
	запись из первой таблицы сопоставляется с каждой записью из другой таблицы по условию, указанному
	после оператора ON, если условие выполняется, тогда строки записываются в результирующую таблицу,
	которая формируется путем конкатенации строк первой и второй таблиц.
*/
SELECT *
FROM Groups INNER JOIN Students
ON Groups.Id = Students.GroupId;

/*
	Естественно, что использовать результаты запроса в таком виде не имеет никакого смысла, однако мы можем
	указать в операторе SELECT только необходимые нам столбцы, и в результирующей таблице будут именно их
	значения в указанной нами последовательности:
*/
SELECT LastName, FirstName, Email, GroupName
FROM Groups INNER JOIN Students
ON Groups.Id = Students.GroupId;

/*
	Как вы, наверное, догадались при помощи оператора INNER JOIN можно осуществлять объединение нескольких
	таблиц, продемонстрируем это на следующем примере.
*/
SELECT FirstName, LastName, Name AS Subject, Assesment, GroupName
FROM Groups AS G JOIN Students AS S
ON G.Id = S.GroupId JOIN Achievements AS A
ON S.Id = A.StudentId JOIN Subjects AS Sb
ON Sb.Id = A.SubjectId;

/*
	При выполнении определенного вида SQL-запросов, которые связаны с получением полной информации из
	таблиц, использование внутреннего объединения не даст желаемого результата. Такое поведение характерно
	при использовании оператора INNER JOIN, потому что в результирующую таблицу будут помещены только те
	записи, которые удовлетворяют условию, указанному после ключевого слова ON.
*/
SELECT FirstName + ' ' + LastName AS FullName, Assesment
FROM Students AS S INNER JOIN Achievements AS A
ON S.Id = A.StudentId;

/*
LEFT JOIN
	Оператор LEFT JOIN (LEFT OUTER JOIN) позволяет создать, так называемое левое внешнее объединение, при
	выполнении которого в результирующий набор помимо строк, удовлетворяющих условию после ключевого
	слова ON, будут записаны даже те строки из таблицы, расположенной слева от оператора, которые
	не удовлетворяют указанному условию.
*/
SELECT FirstName + ' ' + LastName AS FullName, Assesment
FROM Students AS S LEFT JOIN Achievements AS A
ON S.Id = A.StudentId;

/*
	Для того чтобы окончательно убедить вас в полезности внешних объединений, продемонстрируем вам
	два варианта решения еще одной задачи. Допустим, нам необходимо получить информацию о студентах, которые
	пока не получали оценок.
*/
SELECT FirstName + ' ' + LastName AS FullName
FROM Students
WHERE Id NOT IN (
	SELECT StudentId
	FROM Achievements
);

/*
	Более изящным решением поставленной задачи без использования подзапроса является возможность
	применения в данном SQL-запросе оператора LEFT JOIN, который образует более понятную синтаксическую
	конструкцию. К тому же такой запрос выполнится быстрее, потому что для каждого LEFT JOIN создается отдельной
	поток и его выполнение происходит параллельно в отличие от подзапроса, выполнение которого осуществляется
	последовательно с основным запросом в одном потоке.
*/
SELECT FirstName + ' ' + LastName AS FullName
FROM Students AS S LEFT JOIN Achievements AS A
ON S.Id = A.StudentId
WHERE Assesment IS NULL;

/*
	При помощи оператора RIGHT JOIN (RIGHT OUTER JOIN) возможно создать, так называемое правое внешнее
	объединение, при выполнении которого в результирующий набор помимо строк, удовлетворяющих условию
	после ключевого слова ON, будут записаны все строки из таблицы, расположенной справа от оператора, независимо
	от того удовлетворяют они указанному условию или нет.
*/
SELECT FirstName + ' ' + LastName AS FullName, Assesment
FROM Achievements AS A RIGHT JOIN Students AS S
ON S.Id = A.StudentId;

/*
	В следующем примере мы продемонстрируем возможность совместного использования правого и левого
	объединений. Предположим, что нам необходимо получить список всех предметов и информацию о преподавателях,
	которые их читают, ниже представлен возможный вариант запроса:
*/
SELECT [Name] AS [Subject], LastName, FirstName
FROM TeachersSubjects AS TS RIGHT JOIN Subjects AS S
ON S.Id = TS.SubjectId LEFT JOIN Teachers AS T
ON T.Id = TS.TeacherId
ORDER BY [Name];

/*
	Оператор FULL JOIN (FULL OUTER JOIN) позволяет создать полное внешнее объединение, при котором
	в результирующий набор включаются записи из левой таблицы даже в том случае, если для них отсутствуют
	соответствующие записи в правой таблице, а записи из правой таблицы будут помещены в результирующую
	таблицу даже тогда, когда для них нет записей соответствия в левой таблице. Таким образом, полное
	внешнее соединение, по сути, является комбинацией левого и правого внешних объединений.
*/
SELECT FirstName, LastName, GroupName
FROM Students AS S FULL JOIN Groups AS G
ON G.Id = S.GroupId
ORDER BY FirstName;
