-- Создание таблицы Groups:
CREATE TABLE Groups (
    Id INT PRIMARY KEY IDENTITY(1,1),
    GroupName NVARCHAR(50) NOT NULL,
    FacultyId INT
);

-- Создание таблицы Students:
CREATE TABLE Students (
    Id INT PRIMARY KEY IDENTITY(1,1),
    FirstName NVARCHAR(50) NOT NULL,
    LastName NVARCHAR(50) NOT NULL,
    BirthDate DATE NOT NULL,
    Grants DECIMAL(10, 2),
    Email NVARCHAR(100),
    GroupId INT,
    FOREIGN KEY (GroupId) REFERENCES Groups(Id)
);

-- Заполнение таблицы Groups:
INSERT INTO Groups (GroupName, FacultyId)
VALUES 
('3211', 1),
('3212', 2),
('3311', 3);

-- Заполнение таблицы Students:
INSERT INTO Students (FirstName, LastName, BirthDate, Grants, Email, GroupId)
VALUES 
('Anna', 'Ivanova', '2000-03-15', 1200.50, 'anna.ivanova@example.com', 1),
('Boris', 'Petrov', '1999-07-22', 1234.56, 'boris.petrov@example.com', 2),
('Sofia', 'Smirnova', '2001-01-18', 1800.75, 'sofia.smirnova@example.com', 3),
('Dmitry', 'Kozlov', '1998-11-03', NULL, 'dmitry.kozlov@example.com', 1),
('Elena', 'Sokolova', '2000-05-25', 1750.40, 'elena.sokolova@example.com', 2),
('Igor', 'Kuznetsov', '1999-09-12', 1234.56, 'igor.kuznetsov@example.com', 3),
('Maria', 'Popova', '2000-02-05', 1600.60, 'maria.popova@example.com', 1),
('Sergey', 'Volkov', '1998-04-18', NULL, 'sergey.volkov@example.com', 2),
('Olga', 'Zaitseva', '2001-06-14', 1300.45, 'olga.zaitseva@example.com', 3),
('Nikolay', 'Voronin', '2000-12-22', 1234.56, 'nikolay.voronin@example.com', 1);

/*
	Для того, чтобы получить статистические данные в цифровом виде используются функции агрегирования,
	которые предназначены для получения обобщающего значения из определенного количества столбцов, то
	есть результатом выполнения любой функции будет единственное значение.

	В языке T-SQL существует 5 функций агрегирования: COUNT(char/num), AVG(num), SUM(num), MIN(char/num), MAX(char/num).
*/

/*
COUNT()
	Функция COUNT() позволяет определить количество записей в определенном столбце либо во всей таблице.
	Если вызвать функцию COUNT() и передать в качестве параметра символ * (звездочка), то в результате вы получите
	общее количество записей в таблице, включая как повторяющиеся, так и неопределенные значения (NULL-значения)
*/
SELECT COUNT(*) AS [Number of records]
FROM Students;

/*
	Для того чтобы получить количество записей в конкретном столбце таблицы, при вызове функции COUNT()
	необходимо передать в качестве параметра название требуемого столбца. При использовании функции в таком
	виде не учитываются записи, имеющие неопределенное значение в данном столбце.
*/
SELECT COUNT(Grants) AS [Number of grands]
FROM Students;

/*
	В том случае если вам требуется определить количество уникальных записей в определенном столбце, тогда при
	вызове функции COUNT() необходимо указать ключевое слово DISTINCT перед именем столбца.
*/
SELECT COUNT(DISTINCT Grants) AS [Unique of grands]
FROM Students;

/*
AVG()
	Функция AVG() позволяет получить среднее арифметическое значений определенного столбца.
*/
SELECT AVG(Grants) AS [Average grant]
FROM Students;

/*
	Следующий пример будет немного сложнее, допустим нам необходимо определить средний возраст студентов.
	Для того чтобы определить возраст студентов мы используем функцию DATEDIFF(), получая разницу в днях
	между текущей датой и датой рождения студента, производя деление полученного результата на 365.25 мы
	получаем более точные значения.
*/
SELECT AVG(DATEDIFF(d,BirthDate,GETDATE())/365.25) AS [Average age]
FROM Students;

/*
SUM()
	Функция SUM() позволяет вычислить сумму значений заданного столбца.
*/
SELECT SUM(Grants) AS [Sum grants]
FROM Students;

/*
MIN()
	Использование функции MIN() обеспечивает получение самого малого значения в столбце таблицы.
*/
SELECT MIN(BirthDate) AS [Min date of birth]
FROM Students;

/*
MAX()
	Функция MAX() позволяет определить наибольшее значение в указанном столбце.
*/
SELECT MAX(LastName) AS [Maximum last name]
FROM Students;

-- Test
SELECT * FROM Students; 

/*
	При написании SQL-запросов с использованием функций агрегирования, при необходимости, можно осуществлять
	ограничение результата по условию
*/
SELECT COUNT(*) AS [Number of students]
FROM Students
WHERE LastName LIKE 'V%';

/*
	Многотабличный запрос. Допустим нам необходимо узнать количество студентов, которые учатся на 32 потоке:
*/
SELECT COUNT(*) AS [Count of students]
FROM Students AS S, Groups AS G
WHERE G.Id = S.GroupId AND G.GroupName LIKE '33%';

/*
	Все примеры предыдущего раздела возвращали в качестве результатов SQL-запросов только значения
	функций агрегирования. А что произойдет, если нам понадобится дополнительная информация?
*/
SELECT GroupName, COUNT(S.GroupId) AS [Number of students]
FROM Students AS S, Groups AS G
WHERE G.id = S.GroupId;

-- Почему произошла ошибка?

/*
GROUP BY
	Для того чтобы данный SQL-запрос выполнился правильно, необходимо сделать так чтобы название группы
	тоже было в единственном числе, то есть каким-то образом сгруппировать значения в столбце GroupName. 
*/
SELECT GroupName, COUNT(S.GroupId) AS [Number of students]
FROM Groups AS G, Students AS S
WHERE G.Id = S.GroupId
GROUP BY GroupName;

/*
	При необходимости вы можете группировать строки на основе нескольких столбцов, однако в этом случае
	группирование будет осуществляться, основываясь на уникальном сочетании данных во всех столбцах, которые
	участвуют в группировке.
*/
SELECT GroupName, Grants, COUNT(S.GroupId) AS [Number of students]
FROM Groups AS G, Students AS S
WHERE G.Id = S.GroupId
GROUP BY GroupName, Grants;

/*
HAVING
	При использовании функций агрегирования существует необходимость накладывать ограничения на возвращаемые ими результаты,
	именно это является одним из предназначений оператора HAVING.

	Оператор HAVING синтаксически прописывается после оператора GROUP BY, но до оператора ORDER BY:
	SELECT columnName1, columnName2, ...
	FROM tableName
	[WHERE condition]
	[GROUP BY columnName1, columnName2, ...]
	HAVING condition
	[ORDER BY columnName1 ASC | DESC, ...];

	В действительности наличие операторов WHERE, GROUP BY и ORDER BY является необязательным.
*/
SELECT LastName, Grants
FROM Students
GROUP BY LastName, Grants
HAVING AVG(Grants) <= 1700
ORDER BY LastName;

/*
	При помощи следующего SQL-запроса мы сможем определить название групп, количество студентов
	в которых превышает 3 человека:
*/
SELECT GroupName, COUNT(*) AS [Number of students]
FROM Groups AS G, Students AS S
WHERE G.Id = S.GroupId
GROUP BY GroupName
HAVING COUNT(S.GroupId)>3;

/*
	Еще один SQL-запрос демонстрирует возможность проверки в операторе HAVING значений одного из столбцов,
	по которым группируются данные. Допустим необходимо вывести имена и фамилии студентов из определенного
	списка:
*/
SELECT FirstName, LastName
FROM Students
GROUP BY LastName, FirstName
HAVING LastName IN ('Popova', 'Kozlov', 'Sokolova');

/*
	Вывести минимальные значения фамилий студентов, если средняя стипендия превышает 1200:
*/
SELECT MIN(LastName) AS [Minimum last name]
FROM Students
HAVING AVG(Grants)>1200;

/*
	Операторы WHERE и HAVING похожи по способу их использования и тот, и другой содержит условия
	фильтрации данных, однако эти операторы отличаются своим назначением. Условия после оператора
	WHERE определяют, каким образом соединять используемые таблицы и фильтруют отдельные строки данных
	тем самым ограничивая количество выводимых записей в результирующей  таблице. В свою очередь оператор
	HAVING предназначен для фильтрации сгруппированных данных или выполнения условий для функций агрегирования.
*/
SELECT LastName, Grants
FROM Students
WHERE AVG(Grants)>1200;

/*
	В языке SQL реализована возможность создания подзапросов или другими словами вложенных запросов, то
	есть возможность создания такого запроса, который будет помещен внутрь другого запроса

	Обсудим необходимость использования подзапросов на простом примере, допустим нам необходимо вывести
	фамилию, имя и номер группы студентов, которые получают максимальную стипендию.

	Однако полученный результат будет далек от ожидаемого, в данном случае мы получили максимальное значение
	стипендии для каждой группы данных
*/
SELECT LastName, FirstName, GroupName, Grants
FROM Students AS S, Groups AS G
WHERE G.Id = S.GroupId
GROUP BY LastName, FirstName, GroupName, Grants
HAVING Grants = MAX(Grants);

/*
	Для того чтобы наш SQL-запрос вернул требуемые результаты, необходимо сравнивать стипендии студентов
	с максимальным значением стипендии
*/
SELECT LastName, FirstName, GroupName, Grants
FROM Students AS S, Groups AS G
WHERE G.Id = S.GroupId AND Grants = 1800.75;

/*
	Несмотря на то, что в результате выполнения этого SQL-запроса мы получили правильный результирующий
	набор, такой подход не выдерживает никакой критики, ведь максимальное значение стипендии может меняться,
	что в свою очередь приведет к необходимости изменения «магического числа».

	Поэтому для получения максимального значения стипендии целесообразно использовать соответствующий подзапрос/
*/

SELECT LastName, FirstName, GroupName, Grants
FROM Students AS S, Groups AS G
WHERE G.Id = S.GroupId AND Grants = (SELECT MAX(Grants) FROM Students);

/*
	SQL-запросы в основном возвращают множество строк и в этом случае при использовании их в качестве подзапросов
	существует своя особенность.
*/
SELECT LastName, FirstName, Grants
FROM Students
WHERE GroupId = (SELECT Id FROM Groups WHERE GroupName LIKE '%11');

/*
	Во всех случаях, когда запрос может вернуть несколько значений, для их сравнения вместо логических операторов
	следует использовать ключевое слово IN:
*/
SELECT LastName, FirstName, GroupId
FROM Students
WHERE GroupId IN (SELECT Id FROM Groups WHERE GroupName LIKE '%11');

/*
	Как многотабличные запросы, так и подзапросы можно отнести к категории «сложных» запросов. Однако если
	многотабличные запросы возвращают данные, полученные в результате соединения нескольких реально существующих
	таблиц, то подзапросы формируют виртуальные значения, которые используются для сравнения с реально существующими данными.

	Подзапросы позволяют обеспечить значительную гибкость при выполнении запросов, потому что их можно использовать не только
	в операторе WHERE (что было уже продемонстрировано), но и в операторах SELECT, FROM и HAVING.
*/

-- Создание таблицы Achievements:
CREATE TABLE Achievements (
    Id INT PRIMARY KEY IDENTITY(1,1),
    StudentId INT,
    SubjectId INT,
    Assesment INT CHECK (Assesment BETWEEN 1 AND 10), -- Оценка от 1 до 10
    FOREIGN KEY (StudentId) REFERENCES Students(Id),
    FOREIGN KEY (SubjectId) REFERENCES Subjects(Id)
);

-- Заполнение таблицы Achievements:
INSERT INTO Achievements (StudentId, SubjectId, Assesment)
VALUES 
(1, 1, 8), 
(1, 2, 9), 
(2, 3, 7), 
(3, 5, 6), 
(4, 1, 10), 
(5, 4, 5), 
(5, 3, 6), 
(6, 2, 9), 
(7, 5, 8), 
(8, 1, 7);

/*
	Предположим нам необходимо вывести фамилии преподавателей, читающих предметы, по которым студенты
	получают отличные оценки, для этого выполним следующий запрос:
*/
SELECT T.LastName, M.SubjectName
FROM Teachers AS T, TeachersSubjects AS TS,(
	SELECT S.Id AS SubId, S.Name AS SubjectName
	FROM Subjects AS S, Achievements AS A
	WHERE S.Id = A.SubjectId
	GROUP BY S.Name, S.Id
	HAVING MAX(A.Assesment) >= 8
	) AS M
WHERE T.Id = TS.TeacherId AND TS.SubjectId = M.SubId;

/*
	В следующем SQL-запросе мы продемонстрируем возможность использования подзапросов в операторе
	HAVING. При помощи этого запроса мы получим список преподавателей, среднее значение месяца рождения
	которых больше среднего значения месяца рождения студентов:
*/
SELECT LastName, FirstName
FROM Teachers
GROUP BY LastName, FirstName
HAVING AVG(MONTH(BirthDate))>(
	SELECT AVG(MONTH(BirthDate))
	FROM Students
	);

/*
	В том случае если в SQL-запросе применяются подзапросы, то выполнение SQL-операторов в первую очередь
	происходит в подзапросе, а уже потом полученные результаты используются в основном запросе. В одном
	SQL-запросе может быть несколько подзапросов при этом они могут быть вложены друг в друга, в этом случае
	выполнение начинается с подзапроса, который имеет наиболее глубокое вложение.
*/
SELECT GroupName
FROM Groups
WHERE Id IN (
	SELECT GroupId
	FROM Students
	WHERE Grants = (
		SELECT MAX(Grants) FROM Students
		)
	);

/*
	Следует заметить, что существует еще один вид подзапросов, которые называются связанными или коррелированными
	подзапросами. Особенностью выполнения таких подзапросов является их зависимость от значений в основном запросе
	и поэтому они не могут быть обработаны раньше, чем основной запрос
*/
SELECT Subjects.Name,(
	SELECT MAX(A.Assesment)
	FROM Achievements AS A
	WHERE Subjects.Id = A.SubjectId
	) AS Maximum
FROM Subjects;